2、总结每种单例写法的优、缺点。
1，懒汉：被外部调用的时候才初始化，线程安全问题，使用synchronized有性能问题。
2，饿汉：不管用不用，都初始化，浪费内存空间
3，双重校验：指令重排序问题，加volatile
4，静态内部类：利用内部类的特性，需要等到外部类被调用时才使用，JVM底层逻辑，避免线程安全问题；虽然构造方法私有，但可能被反射攻击，序列化也可破环
5，序列化单例：
序列化：把内存中的状态通过转换成字节码的形式，从而转换一个IO流，写入到其他地方
反序列化：将已经持久化的字节码内容，转换为io流，通过io流的读取，进而将读取的内容转换成Java对象，再转换过程中，会重新创建对象。
解决办法：重写readResolve方法，覆盖反序列化出来的对象，还是被创建了2次，但发生在JVM层面，相对安全，之前反序列化出来的对象被GC回收；
6，枚举单例-注册单例：根据类名和枚举名字确定一个枚举值，被JVM保存。从jdk层面保证枚举不被序列化和反射来破坏；
